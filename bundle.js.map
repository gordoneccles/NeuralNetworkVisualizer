{"version":3,"sources":["webpack:///webpack/bootstrap 0b1a7bcbe83c6d8be7c1","webpack:///./entry.js","webpack:///./neural_network/neural_network.js","webpack:///./neural_network/my_math.js","webpack:///./neural_network/matrix.js","webpack:///./visualization/visualizer.js","webpack:///./visualization/text.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACXA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,oBAAoB,KAAK;AAC5C;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP,MAAK;AACL;;AAEA;AACA;;AAEA,iBAAgB,aAAa;AAC7B;AACA;;AAEA;AACA;;AAEA;;;;;;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACbA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;;AAEA;AACA;;AAEA;AACA;;AAEA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;;AAEA;AACA;;AAEA;AACA;;AAEA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;ACrJA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA2C,QAAQ;AACnD;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAiB,QAAQ;AACzB;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAsB,wBAAwB;;AAE9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAgB,QAAQ;AACxB;AACA;AACA,mBAAkB,EAAE;AACpB;AACA;AACA,+CAA8C,SAAS,QAAQ,MAAM;;AAErE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAgB,QAAQ;AACxB;AACA;AACA,mBAAkB,EAAE;AACpB,qDAAoD;AACpD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAgB,QAAQ;AACxB;AACA;AACA,mBAAkB,EAAE;AACpB,qDAAoD;AACpD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAwB,IAAI;AAC5B,mCAAkC,OAAO,GAAG,OAAO,OAAO;AAC1D;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2CAA0C,YAAY;AACtD;AACA,oCAAmC,QAAQ,GAAG,OAAO,QAAQ,GAAG;;AAEhE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAgB,OAAO;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gCAA+B,QAAQ;;AAEvC;AACA;AACA,yBAAwB,MAAM,GAAG,MAAM,GAAG,MAAM;AAChD;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAa,WAAW;AACxB;;AAEA,gBAAe,YAAY;AAC3B;;AAEA;AACA;AACA;AACA;AACA,iBAAgB,mCAAmC;AACnD,MAAK;AACL,IAAG;AACH;;AAEA;AACA;AACA,2BAA0B,+BAA+B;AACzD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wBAAuB,SAAS;;AAEhC;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA,2BAA0B,+BAA+B;;AAEzD;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA,6DAA4D,MAAM;AAClE;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;AC3fA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 0b1a7bcbe83c6d8be7c1\n **/","const NeuralNetwork = require('./neural_network/neural_network.js');\nconst Visualizer = require('./visualization/visualizer.js');\n\ndocument.addEventListener(\"DOMContentLoaded\",\n  () => {\n    let trainingData = document.getElementById('training-data').innerHTML;\n    let testData = document.getElementById('test-data').innerHTML;\n    let netty = new NeuralNetwork(784, 100, 10, 0.1);\n\n    let vizy = new Visualizer('#header', '#work-space', netty, trainingData, testData);\n  }\n);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./entry.js\n ** module id = 0\n ** module chunks = 0\n **/","const MyMath = require('./my_math.js');\nconst Matrix = require('./matrix.js');\n\nlet NeuralNetwork = function(numInputNodes, numHiddenNodes, numOutputNodes, learningRate) {\n  this.numInputNodes = numInputNodes;\n  this.numHiddenNodes = numHiddenNodes;\n  this.numOutputNodes = numOutputNodes;\n  this.learningRate = learningRate;\n\n  let stdDev = Math.pow(this.numHiddenNodes, -0.5);\n  this.wih = new Matrix(this.numHiddenNodes, this.numInputNodes);\n  this.wih = this.wih.map( () =>\n    MyMath.randAroundZero(stdDev)\n  );\n\n  stdDev = Math.pow(this.numOutputNodes, -0.5);\n  this.who = new Matrix(this.numOutputNodes, this.numHiddenNodes);\n  this.who = this.who.map( () =>\n    MyMath.randAroundZero(stdDev)\n  );\n};\n\nNeuralNetwork.prototype.query = function(inputs) {\n  this.inputs = new Matrix(inputs).transpose();\n\n  this.hiddenInputs = this.wih.dot(this.inputs);\n  this.hiddenOutputs = this.hiddenInputs.map( x =>\n    MyMath.sigmoid(x)\n  );\n\n  this.finalInputs = this.who.dot(this.hiddenOutputs);\n  this.finalOutputs = this.finalInputs.map( x =>\n    MyMath.sigmoid(x)\n  );\n\n  return this.finalOutputs;\n};\n\nNeuralNetwork.prototype.train = function(inputs, targets) {\n  inputs = new Matrix(inputs).transpose();\n  targets = new Matrix(targets).transpose();\n\n  let hiddenInputs = this.wih.dot(inputs);\n  let hiddenOutputs = hiddenInputs.map( x =>\n    MyMath.sigmoid(x)\n  );\n\n  let finalInputs = this.who.dot(hiddenOutputs);\n  let finalOutputs = finalInputs.map( x =>\n    MyMath.sigmoid(x)\n  );\n\n  let outputErrors = targets.map( (x, i, j) => x - finalOutputs.get(i, j));\n  let hiddenErrors = this.who.transpose().dot(outputErrors);\n\n  let invFinalOut = finalOutputs.map( x => 1 - x );\n  let whoCorrections = outputErrors.times(finalOutputs).times(invFinalOut);\n  whoCorrections = whoCorrections.dot(hiddenOutputs.transpose()).map( x => x * this.learningRate );\n  this.who = this.who.map( (x, i, j) => x + whoCorrections.get(i, j));\n\n  let invHiddenOut = hiddenOutputs.map( x => 1 - x );\n  let wihCorrections = hiddenErrors.times(hiddenOutputs).times(invHiddenOut);\n  wihCorrections = wihCorrections.dot(inputs.transpose()).map( x => x * this.learningRate );\n  this.wih = this.wih.map( (x, i, j) => x + wihCorrections.get(i, j));\n};\n\nNeuralNetwork.prototype.learn = function(data, callback) {\n  let trainingDigits = data.split(/\\r?\\n/);\n\n  trainingDigits.forEach( digit => {\n    let allValues = digit.split(',').map( x => parseFloat(x));\n    let inputs = allValues.slice(1, allValues.length).map( x => x / 255.0 * 0.99 + 0.01);\n\n    let targets = [];\n    let j = 0;\n    while(j < 10) { targets.push(0.01); j++; }\n    let idx = parseInt(allValues[0]);\n    targets[idx] = 0.99;\n    this.train(inputs, targets);\n  });\n\n  callback();\n};\n\nNeuralNetwork.prototype.interpret = function(digitCSV) {\n  let allValues = digitCSV.split(',').map( x => parseFloat(x));\n  let inputs = allValues.slice(1, allValues.length).map( x => x / 255.0 * 0.99 + 0.01);\n\n  let outputs = this.query(inputs).toArray();\n  this.chosenDigit = outputs.indexOf(Math.max(...outputs));\n};\n\nNeuralNetwork.prototype.prepSample = function(numSampleInputs, numSampleHiddenInputs) {\n    this.sampleInputs = [];\n    this.sampleHiddenInputs = [];\n    this.sampleHiddenOutputs = [];\n    this.sampleWIH = new Matrix(numSampleHiddenInputs, numSampleInputs);\n    this.sampleWHO = new Matrix(this.numOutputNodes, numSampleHiddenInputs);\n\n    let sampleInputIdxs = NeuralNetwork.randomIdxs(this.numInputNodes, numSampleInputs);\n    let sampleHiddenIdxs = NeuralNetwork.randomIdxs(this.numHiddenNodes, numSampleHiddenInputs);\n\n    let inputs = this.inputs.toArray();\n    let hiddenInputs = this.hiddenInputs.toArray();\n    let hiddenOutputs = this.hiddenOutputs.toArray();\n\n    sampleInputIdxs.forEach( (iIdx, i) => {\n      this.sampleInputs.push(inputs[iIdx]);\n\n      sampleHiddenIdxs.forEach( (hIdx, j) => {\n        this.sampleWIH.set(j, i, this.wih.get(hIdx, iIdx));\n      });\n    });\n\n    sampleHiddenIdxs.forEach( (hIdx, i) => {\n      this.sampleHiddenInputs.push(hiddenInputs[hIdx]);\n      this.sampleHiddenOutputs.push(hiddenOutputs[hIdx]);\n\n      [...Array(10).keys()].forEach( (oIdx, j) => {\n        this.sampleWHO.set(j, i, this.who.get(oIdx, hIdx));\n      });\n    });\n};\n\nNeuralNetwork.randomIdxs = function(arrayLength, numIdxs) {\n  let idxs = [];\n\n  for(let i = 0; i < numIdxs; i++) {\n    idxs.push(Math.floor(Math.random()*arrayLength));\n  }\n\n  return idxs;\n};\n\nmodule.exports = NeuralNetwork;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./neural_network/neural_network.js\n ** module id = 1\n ** module chunks = 0\n **/","const MyMath = {\n  randAroundZero(stdDev) {\n    let theta = 2 * Math.PI * Math.random();\n    let rho = Math.sqrt(-2 * Math.log(1 - Math.random()));\n    let scale = stdDev * rho;\n    return scale * Math.cos(theta);\n  },\n  sigmoid(x) {\n    let pow = Math.pow(Math.E, -x);\n    return (1.0 / (1.0 + pow));\n  }\n};\n\nmodule.exports = MyMath;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./neural_network/my_math.js\n ** module id = 2\n ** module chunks = 0\n **/","const Matrix = function() {\n  this.matrix = [];\n\n  if (arguments[0] instanceof Array) {\n    this.width = arguments[0].length;\n    this.height = 0;\n\n    let i = 0;\n    while(i < arguments.length) {\n      this.matrix.push(arguments[i]);\n      this.height++;\n      i++;\n    }\n  } else if (typeof(arguments[0]) === 'number' ) {\n    this.height = arguments[0];\n    this.width = arguments[1];\n\n    let i = 0;\n    while (i < this.height) {\n      this.matrix.push([]);\n      i++;\n    }\n  }\n};\n\nMatrix.prototype.set = function(i, j, val) {\n  this.matrix[i][j] = val;\n};\n\nMatrix.prototype.get = function(i, j) {\n  return this.matrix[i][j];\n};\n\nMatrix.prototype.each = function(callback) {\n  let i = 0; let j = 0;\n\n  while (i < this.height) {\n    while (j < this.width) {\n      callback(this.matrix[i][j], i, j);\n      j++;\n    }\n    j = 0; i++;\n  }\n\n  return this.matrix;\n};\n\nMatrix.prototype.map = function(callback) {\n  let result = new Matrix(this.height, this.width);\n\n  let i = 0; let j = 0;\n  while (i < this.height) {\n    while (j < this.width) {\n      result.set(i, j, callback(this.matrix[i][j], i, j));\n      j++;\n    }\n    j = 0; i++;\n  }\n\n  return result;\n};\n\nMatrix.prototype.row = function(idx) {\n  return this.matrix[idx];\n};\n\nMatrix.prototype.col = function(idx) {\n  let column = [];\n\n  let i = 0;\n  while (i < this.height) {\n    column.push(this.matrix[i][idx]);\n    i++;\n  }\n\n  return column;\n};\n\nMatrix.prototype.dot = function(other) {\n  if (this.width !== other.height) {\n    throw \"Incompatible matrices.\";\n  }\n\n  let resultHeight = this.height;\n  let resultWidth = other.width;\n  let result = new Matrix(resultHeight, resultWidth);\n\n  let i = 0; let j = 0;\n  while (i < resultHeight) {\n    while (j < resultWidth) {\n      let row = this.row(i);\n      let col = other.col(j);\n      result.set(i, j, Matrix.sumProduct(row, col));\n      j++;\n    }\n    j = 0; i++;\n  }\n\n  return result;\n};\n\nMatrix.sumProduct = function(arr1, arr2) {\n  let sum = 0;\n\n  arr1.forEach( (val, idx) =>\n    sum += (arr1[idx] * arr2[idx])\n  );\n\n  return sum;\n};\n\nMatrix.prototype.transpose = function() {\n  let result = new Matrix(this.width, this.height);\n\n  let i = 0; let j = 0;\n  while (i < this.height) {\n    while (j < this.width) {\n      result.set(j, i, this.get(i, j));\n      j++;\n    }\n    j = 0; i++;\n  }\n\n  return result;\n};\n\nMatrix.prototype.times = function(other) {\n  let result = new Matrix(this.height, this.width);\n\n  let i = 0; let j = 0;\n  while (i < this.height) {\n    while (j < this.width) {\n      result.set(i, j, this.get(i, j) * other.get(i, j));\n      j++;\n    }\n    j = 0; i++;\n  }\n\n  return result;\n};\n\nMatrix.prototype.toArray = function() {\n  let arr = [];\n\n  this.each( x => arr.push(x) );\n\n  return arr;\n};\n\nmodule.exports = Matrix;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./neural_network/matrix.js\n ** module id = 3\n ** module chunks = 0\n **/","const Matrix = require('../neural_network/matrix.js');\nconst Text = require ('./text.js');\n\nconst Visualizer = function(headerQuery, workSpaceQuery, neuralNetwork, trainingData, testData) {\n  this.headerSpace = $(headerQuery);\n  this.workSpace = $(workSpaceQuery);\n  this.neuralNetwork = neuralNetwork;\n  this.testDigits = testData.split(/\\r?\\n/);\n\n  this.displayIntro();\n  this.removeLoader();\n  // setTimeout(() => this.neuralNetwork.learn(trainingData, this.removeLoader.bind(this)), 5000);\n};\n\nVisualizer.prototype.drawLoader = function() {\n  let training = document.createElement(\"div\");\n  training.id = \"training\";\n  training.className = \"sk-cube-grid\";\n\n  [...Array(9).keys()].forEach( idx => {\n    let squareEl = document.createElement(\"div\");\n    squareEl.className = `sk-cube sk-cube${idx + 1}`;\n  training.appendChild(squareEl);\n  });\n\n  $('body').append(training);\n};\n\nVisualizer.prototype.removeLoader = function() {\n  $('#training').remove();\n\n  let onward = this.nextButton(this.displayNumberPicker.bind(this), 'onward');\n  $('body').append(onward);\n};\n\nVisualizer.prototype.displayIntro = function() {\n  let intro = document.createElement('div');\n  intro.id = 'intro';\n\n  intro.innerHTML = Text.intro;\n\n  this.drawLoader();\n  this.workSpace.append(intro);\n};\n\nVisualizer.prototype.displayNumberPicker = function() {\n  $('#intro').remove();\n  Visualizer.removeNextButton();\n\n  let digitsBox = document.createElement('div');\n  digitsBox.id = 'digits-box';\n  digitsBox.className = 'visual-box center';\n\n  for (let i = 0; i < 10; i++) {\n    let digit = document.createElement('div');\n    digit.className = 'digit hoverable';\n    digit.id = i; digit.innerHTML = i;\n    $(digit).on('click', this.pickDigit.bind(this));\n    digitsBox.appendChild(digit);\n  }\n\n  let draw = document.createElement('div');\n  draw.id = 'draw-button';\n  draw.className = 'digit hoverable';\n  draw.innerHTML = 'Draw One!';\n  $(draw).on('click', this.drawNewImage.bind(this));\n  digitsBox.appendChild(draw);\n\n  this.titleSpace = document.createElement('h3');\n  this.titleSpace.id = \"title\";\n  this.titleSpace.innerHTML = Text.header1;\n  this.headerSpace.append(this.titleSpace);\n  this.workSpace.append(digitsBox);\n};\n\nVisualizer.prototype.drawNewImage = function() {\n  let csv = new Array(784).fill(0).join(',');\n\n  window.mouseDown = 0;\n  document.body.onmousedown = function() {\n    window.mouseDown++;\n  };\n  document.body.onmouseup = function() {\n    window.mouseDown--;\n  };\n  const greyscaleMap = d3.scaleLinear()\n                          .domain([0, 255])\n                          .range([\"#FFFFFF\", \"#000000\"]);\n\n  this.drawImage(csv,\n    greyscaleMap,\n    Visualizer.drawPixel,\n    function(){}\n  );\n\n  this.headerSpace.append(this.nextButton(this.submitImage.bind(this), 'submit'));\n  this.titleSpace.innerHTML = Text.header1_5;\n  $('#digits-box').remove();\n};\n\nVisualizer.prototype.submitImage = function(event) {\n  Visualizer.removeNextButton();\n\n  let csv = d3.selectAll('rect').data();\n  csv = 'x,' + csv.join(',');\n\n  this.neuralNetwork.interpret(csv);\n  this.neuralNetwork.prepSample(20, 15);\n\n  this.displayCSV(csv);\n};\n\nVisualizer.prototype.pickDigit = function(event) {\n  $('#digits-box').remove();\n\n  let csv = this.testDigits[parseInt(event.target.id)];\n\n  this.neuralNetwork.interpret(csv);\n  this.neuralNetwork.prepSample(20, 15);\n\n  this.displayCSV(csv);\n};\n\nVisualizer.prototype.displayCSV = function(csv) {\n  if( $('#csv-box')) { $('#csv-box').remove(); }\n\n  const greyscaleMap = d3.scaleLinear()\n                          .domain([0, 255])\n                          .range([\"#FFFFFF\", \"#000000\"]);\n\n  this.drawImage(csv.slice(2, csv.length),\n    greyscaleMap,\n    Visualizer.floatValue,\n    Visualizer.removeFloat\n  );\n\n  this.headerSpace.append(this.nextButton(this.displayScaledCSV));\n  this.titleSpace.innerHTML = Text.header2;\n};\n\nVisualizer.prototype.displayScaledCSV = function() {\n  Visualizer.removeNextButton();\n  $('#csv-box').remove();\n\n  let scaledCSV = this.neuralNetwork.inputs.toArray().map( x => Math.floor(x * 100) / 100 ).join(',');\n\n  const greyscaleMap = d3.scaleLinear()\n                          .domain([0.01, 0.99])\n                          .range([\"#FFFFFF\", \"#000000\"]);\n\n  this.drawImage(scaledCSV,\n    greyscaleMap,\n    Visualizer.floatValue,\n    Visualizer.removeFloat\n  );\n\n  this.headerSpace.append(this.nextButton(this.displayInputNodes));\n  this.titleSpace.innerHTML = Text.header3;\n};\n\n\nVisualizer.prototype.displayInputNodes = function() {\n  Visualizer.removeNextButton();\n  $('#csv-box').remove();\n\n  let inputNodesBox = document.createElement('div');\n  inputNodesBox.id = 'input-nodes-box';\n  inputNodesBox.className = 'visual-box hide';\n\n  let inputNodesList = document.createElement('div');\n  inputNodesList.className = 'node-list';\n  let sampleNodeVals = this.neuralNetwork.sampleInputs;\n  const greyscaleMap = d3.scaleLinear()\n                          .domain([0.01, 0.99])\n                          .range([\"#F5F5F5\", \"#262626\"]);\n\n  for(let i = 0; i < 20; i++) {\n    let node = document.createElement('div');\n    node.className = 'input node';\n    node.id = `i${i}`;\n    let bgColor = greyscaleMap(sampleNodeVals[i]);\n    let color = (sampleNodeVals[i] < 0.50) ? ('rgb(0,0,0)') : ('rgb(255,255,255)');\n    $(node).attr('style', `background-color:${bgColor};color:${color}`);\n\n    let inputValue = document.createElement('p');\n    inputValue.innerHTML = Math.floor(sampleNodeVals[i] * 100) / 100;\n    node.appendChild(inputValue);\n    inputNodesList.appendChild(node);\n  }\n\n  inputNodesBox.appendChild(inputNodesList);\n  this.workSpace.append(inputNodesBox);\n  this.headerSpace.append(this.nextButton(this.displayHiddenNodes));\n\n  this.titleSpace.innerHTML = Text.header4;\n  setTimeout(() => inputNodesBox.className = 'visual-box center', 0);\n};\n\nVisualizer.prototype.displayHiddenNodes = function() {\n  $('p').remove();\n  Visualizer.removeNextButton();\n\n  let hiddenNodesBox = document.createElement('div');\n  hiddenNodesBox.id = 'hidden-nodes-box';\n  hiddenNodesBox.className = 'visual-box hide';\n\n  let hiddenNodesList = document.createElement('div');\n  hiddenNodesList.className = 'node-list';\n\n  for(let i = 0; i < 15; i ++) {\n    let node = document.createElement('div');\n    node.className = 'hidden node';\n    node.id = `h${i}`;\n    $(node).attr('style', 'background-color:#FFFFFF;border:1px solid black');\n    hiddenNodesList.appendChild(node);\n  }\n\n  hiddenNodesBox.appendChild(hiddenNodesList);\n  this.workSpace.append(hiddenNodesBox);\n\n  let sigmoidCallback = this.sigmoidNodes.bind(this,\n    this.neuralNetwork.sampleHiddenOutputs,\n    $('.node.hidden'),\n    this.displayOutputNodes,\n    Text.header7\n  );\n\n  let fireCallback = this.fireNodes.bind(this,\n    this.neuralNetwork.sampleHiddenInputs,\n    this.neuralNetwork.sampleHiddenOutputs,\n    $('.node.hidden'),\n    sigmoidCallback,\n    Text.header6\n  );\n\n  this.headerSpace.append(this.nextButton(fireCallback));\n\n  this.connectLayers('input', 'hidden', this.neuralNetwork.sampleWIH);\n\n  this.titleSpace.innerHTML = Text.header5;\n  document.getElementById('input-nodes-box').className = 'visual-box top';\n  setTimeout(() => hiddenNodesBox.className = 'visual-box center', 0);\n};\n\nVisualizer.prototype.sigmoidNodes = function(outputVals, nodeSelection, nextCallback, text) {\n  Visualizer.removeNextButton();\n\n  nodeSelection.each( (idx, node) => {\n    node.children[0].innerHTML = Math.floor(outputVals[idx] * 100) / 100;\n  });\n\n  this.headerSpace.append(this.nextButton(nextCallback));\n  this.titleSpace.innerHTML = text;\n};\n\nVisualizer.prototype.displayOutputNodes = function() {\n  Visualizer.removeNextButton();\n  $('p').remove();\n\n  let outputNodesBox = document.createElement('div');\n  outputNodesBox.id = 'output-nodes-box';\n  outputNodesBox.className = 'visual-box hide';\n\n  let outputNodesList = document.createElement('div');\n  outputNodesList.className = 'node-list';\n\n  for(let i = 0; i < 10; i ++) {\n    let node = document.createElement('div');\n    node.className = 'output node';\n    node.id = `o${i}`;\n    $(node).attr('style', 'background-color:#FFFFFF;border:1px solid black');\n    outputNodesList.appendChild(node);\n  }\n\n  outputNodesBox.appendChild(outputNodesList);\n  this.workSpace.append(outputNodesBox);\n\n  let sigmoidCallback = this.sigmoidNodes.bind(this,\n    this.neuralNetwork.finalOutputs.toArray(),\n    $('.node.output'),\n    this.clearTopLayers.bind(this),\n    Text.header10\n  );\n\n  let fireCallback = this.fireNodes.bind(this,\n    this.neuralNetwork.finalInputs.toArray(),\n    this.neuralNetwork.finalOutputs.toArray(),\n    $('.node.output'),\n    sigmoidCallback,\n    Text.header9\n  );\n\n  this.headerSpace.append(this.nextButton(fireCallback));\n\n  this.connectLayers('hidden', 'output', this.neuralNetwork.sampleWHO);\n\n  this.titleSpace.innerHTML = Text.header8;\n  setTimeout(() => outputNodesBox.className = 'visual-box bottom', 0);\n};\n\nVisualizer.prototype.clearTopLayers = function() {\n  Visualizer.removeNextButton();\n  $('#input-nodes-box').remove();\n  $('#hidden-nodes-box').remove();\n  $('.node.output').off();\n  $('#output-nodes-box').attr('class', 'visual-box center');\n  setTimeout(() => this.displayAnswer(), 300);\n};\n\nVisualizer.prototype.displayAnswer = function() {\n  this.headerSpace.append(this.nextButton(this.reset.bind(this), 'again!'));\n  this.titleSpace.innerHTML = Text.header11;\n\n  let digits = document.createElement('div');\n  digits.id = 'answer-digits';\n  digits.className = 'hide';\n  let digitY = $('#output-nodes-box').get(0).getBoundingClientRect().bottom;\n\n  [...Array(10).keys()].forEach( idx => {\n    let digit = document.createElement('div');\n    digit.className = 'answer-digit';\n    digit.innerHTML = idx;\n    let digitX = $(`#o${idx}`).get(0).getBoundingClientRect().left;\n    $(digit).attr('style', `top:${digitY}px;left:${digitX}px`);\n    digits.appendChild(digit);\n  });\n\n  let chosenDigit = this.neuralNetwork.chosenDigit;\n  let chosenNodeCoords = this.answerNode().get(0).getBoundingClientRect();\n  let chosenX = chosenNodeCoords.left;\n  let chosenY = chosenNodeCoords.top;\n\n  let arrowBox = document.createElement('div');\n  arrowBox.id = 'arrow-box';\n  arrowBox.className = 'hide';\n  let arrow = document.createElement('div');\n  arrow.className = 'arrow';\n  arrow.innerHTML = `I think that was a ${chosenDigit}`;\n  arrowBox.appendChild(arrow);\n  $(arrowBox).attr('style', `top:${chosenY}px;left:${chosenX}px;transform:translateY(-200%) translateX(-40%)`);\n\n  $('body').append(digits);\n  $('body').append(arrowBox);\n  setTimeout(() => digits.className = '', 10);\n  setTimeout(() => arrowBox.className = '', 10);\n};\n\nVisualizer.prototype.reset = function() {\n  $('.weights-matrix').remove();\n  $('#arrow-box').remove();\n  $('#answer-digits').remove();\n  $('#output-nodes-box').remove();\n  $('.next-button').remove();\n  this.titleSpace.remove();\n\n  this.displayNumberPicker();\n};\n\nVisualizer.prototype.answerNode = function() {\n  let answer = this.neuralNetwork.chosenDigit;\n  return $(`#o${answer}`);\n};\n\nVisualizer.prototype.drawImage = function(csv, colorFunc, mouseOverFunc, mouseOutFunc) {\n  csv = csv.split(\",\").map( val => parseFloat(val) );\n  let image = d3.select('#work-space')\n                  .append(\"svg\")\n                  .attr(\"height\", 450)\n                  .attr(\"width\", 300)\n                  .attr(\"id\", 'csv-box');\n\n  let xFunc = function(d, i) {\n    return Math.floor(12*(i % 28));\n  };\n  let yFunc = function(d, i) {\n    return (16*Math.floor(i / 28));\n  };\n  image.selectAll('rect')\n      .data(csv)\n      .enter()\n      .append('rect')\n      .attr('class', 'pixel')\n      .attr(\"x\", (d, i) => xFunc(d, i))\n      .attr(\"y\", (d, i) => yFunc(d, i))\n      .attr(\"height\", 16)\n      .attr(\"width\", 12)\n      .style(\"fill\", d => colorFunc(d))\n      .on('mouseover', (d, i, rect) => mouseOverFunc(d, i, rect))\n      .on('mouseout', (d, i, rect) => mouseOutFunc(d, i, rect));\n};\n\nVisualizer.floatValue = function(d, i, rect) {\n  d3.select(rect[i]).attr('stroke-width', 2).attr('width', 11).attr('height', 15).attr('stroke', '#FF3333');\n  let text = document.createElement('div');\n  text.innerHTML = d;\n  text.className = 'value-callout';\n  $('body').append(text);\n};\n\nVisualizer.removeFloat = function(d, i, rect) {\n  d3.select(rect[i]).attr('stroke-width', 0).attr('width', 12).attr('height', 16);\n  $('.value-callout').remove();\n};\n\nVisualizer.drawPixel = function(d, i, rect) {\n  if (window.mouseDown === 0) { return; }\n\n  let color = Math.floor(Math.random() * 30);\n  d3.select(rect[i])\n  .style('fill', `rgb(${color},${color},${color})`)\n  .data([ 255 - color ]);\n};\n\nVisualizer.prototype.connectLayers = function(firstClass, secondClass, weightsMatrix) {\n  let weights = d3.select('body').append('svg');\n  weights.attr('class', 'weights-matrix');\n\n  let scale = d3.scaleLinear().domain([-0.5, 0.5]).range([0, 1]);\n  $(`.node.${firstClass}`).each( (idxI, nodeI) => {\n    $(nodeI).hover(this.drawPaths, this.hidePaths);\n\n    $(`.node.${secondClass}`).each( (idxJ, nodeJ) => {\n      $(nodeJ).hover(this.drawPaths, this.hidePaths);\n\n      let color = d3.interpolateInferno(scale(weightsMatrix.get(idxJ, idxI)));\n      let path = weights.append('line')\n        .attr('stroke-width', 4)\n        .attr('stroke', color)\n        .data([{ node1: nodeI.id, node2: nodeJ.id }]);\n    });\n  });\n};\n\nVisualizer.prototype.drawPaths = function(event) {\n  let source = event.target;\n  if (source.id === '' ) { source = source.parentElement; }\n  let x1 = source.getBoundingClientRect().left + ($(source).width() / 2);\n  let y1 = source.getBoundingClientRect().bottom - ($(source).height() / 2);\n\n  let paths = d3.selectAll('line').filter( d =>\n    (d.node1 === source.id  || d.node2 === source.id)\n  );\n\n  paths.each( (d, i, paths) => {\n    let targetId = (d.node1 === source.id) ? (d.node2) : (d.node1);\n    let target = $(`#${targetId}`)[0];\n\n    let x2 = target.getBoundingClientRect().left + ($(target).width() / 2);\n    let y2 = target.getBoundingClientRect().top + ($(target).height() / 2);\n    d3.select(paths[i]).attr('x1', x1).attr('y1', y1).attr('x2', x2).attr('y2', y2).attr('stroke-width', 4);\n  });\n};\n\nVisualizer.prototype.hidePaths = function(event) {\n  let source = event.target;\n  if (source.id === '' ) { source = source.parentElement; }\n\n  let paths = d3.selectAll('line').filter( d =>\n    (d.node1 === source.id  || d.node2 === source.id)\n  );\n\n  paths.each( (d, i, paths) => {\n    d3.select(paths[i]).attr('stroke-width', 0);\n  });\n};\n\nVisualizer.prototype.fireNodes = function(inputVals, outputVals, nodeSelection, nextCallback, title) {\n  Visualizer.removeNextButton();\n  let next = this.nextButton(nextCallback);\n  let i = 0;\n\n  let firing = setInterval( () => {\n    $(nodeSelection[i - 1]).trigger('mouseout');\n\n    if (i === nodeSelection.length) {\n      window.clearInterval(firing);\n      this.headerSpace.append(next);\n    } else {\n      let value = document.createElement('p');\n      value.innerHTML = (Math.floor(inputVals[i] * 100) / 100);\n      let color = d3.interpolateInferno(outputVals[i]);\n\n      $(nodeSelection[i]).trigger('mouseover');\n      $(nodeSelection[i]).attr('style', `background-color:${color}`);\n      nodeSelection[i].appendChild(value);\n    }\n\n    i++;\n  }, 300);\n\n  this.titleSpace.innerHTML = title;\n};\n\nVisualizer.prototype.nextButton = function(callback, buttonText) {\n  buttonText = (buttonText === undefined) ? ('cool') : (buttonText);\n  let button = document.createElement('h3');\n  button.className = 'next-button hoverable';\n  button.id = `${buttonText.toLowerCase()}`;\n  button.innerHTML = buttonText;\n  $(button).on('click', callback.bind(this));\n  return button;\n};\n\nVisualizer.removeNextButton = function() {\n  $('.next-button').remove();\n};\n\nmodule.exports = Visualizer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./visualization/visualizer.js\n ** module id = 4\n ** module chunks = 0\n **/","const Text = {\n  intro: \"Hi, I'm a neural network. I'm going to show you how I identify handwritten numbers. Before we begin, let me tell you a bit about myself. Fundamentally I'm just a bunch of connected \\\"nodes\\\". Each node knows two things: it's own number value and its children nodes. Every node has the ability to \\\"fire\\\", at which point the node's value is transmitted to all child nodes. Not all connections are equal, though. Some are weighted more heavily than others.<br><br>\\\n  \\\n  My nodes are organized into three layers. The first layer is for taking in information, in my case pixel data, and it's by far the largest with about 800 nodes. The second layer is much smaller at 100 nodes, and it serves to aggregate firing from the first layer. My final layer has exactly 10 nodes, and each one corresponds to a digit zero through nine. After a little training (it's happening right now!) I adjust the connections between nodes so that one node in the final layer wins out, and that's my guess at which digit I'm looking at. Sounding a little abstract? Perfect! That's why I'm here. Onward!\",\n\n  header1: \"First you'll need to pick a number.\",\n\n  header1_5: \"Click and drag to draw your digit. Write big!\",\n\n  header2: \"Great, here's your image. It has 784 pixels (28x28), each with a greyscale value. <br>\\\n  Hover over a pixel's to see its value.\",\n\n  header3: \"I like values between 0 and 1, so I've scaled each pixel value. Hover again!\",\n\n  header4: \"For each of the 784 pixels, I have a node in my first layer.<br>\\\n  Each node takes in a single pixel's value. Here's a small sample.\",\n\n  header5: \"I have 100 nodes in my second layer, so again this is just a sample. Hover over a node to see its connections.<br>\\\n  Connection are weighted between 0.5 and -0.5, visualized as a yellow-orange-red-blue scale.\",\n\n  header6: \"Fire! Each node in the second layer sums the weighted inputs from the first layer.\",\n\n  header7: \"To keep me in my happy place, I've scaled everything between 0 and 1 again.\",\n\n  header8: \"Alright, let's bring out the third and final layer. Hover to see those connections.\",\n\n  header9: \"Fire! Just like last time, each node sums its inputs.\",\n\n  header10: \"One more time, I'll scale everything down.\",\n\n  header11: \"See how one node stands out? All that chatter between nodes in the first two layers had the effect of activating that one node the final layer and silencing the rest.\"\n\n};\n\nmodule.exports = Text;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./visualization/text.js\n ** module id = 5\n ** module chunks = 0\n **/"],"sourceRoot":""}